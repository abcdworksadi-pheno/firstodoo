# name: CI/CD Odoo

# on:
#   push:
#     branches: ["main"]

# jobs:
#   test:
#     name: Test Odoo Modules
#     runs-on: ubuntu-latest

#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       - name: Install Python deps
#         run: |
#           sudo apt update
#           sudo apt install -y python3 python3-pip
#           pip3 install pylint

#       - name: Lint Odoo modules
#         run: |
#           pylint ./addons/* || true

#       - name: Clean old test containers
#         run: |
#           docker compose -f docker-compose.test.yml down -v || true

#       - name: Run Odoo tests
#         run: |
#           docker compose -f docker-compose.test.yml up --abort-on-container-exit --exit-code-from odoo
#         continue-on-error: false

#   deploy:
#     name: Deploy to Server
#     needs: test
#     runs-on: self-hosted

#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       - name: Sync files to server
#         run: |
#           rsync -avz --delete \
#             ./ \
#             $HOME/firstodoo/

#       - name: Rebuild Odoo with retry
#         run: |
#           cd $HOME/firstodoo

#           echo "Stopping old containers..."
#           docker-compose down || true

#           echo "Building new containers..."
#           for i in {1..5}; do
#             docker-compose up -d --build && break
#             echo "Retrying build ($i/5)..."
#             sleep 3
#           done

#       - name: Install new module
#         run: |
#           docker exec odoo18 \
#             odoo -d odoo18 \
#                 -u ALL \
#                 --db_host=db \
#                 --db_port=5432 \
#                 --db_user=odoo18 \
#                 --db_password=odoo18 \
#                 --stop-after-init


#       - name: Check Odoo health
#         run: |
#           curl -f http://localhost:8069 || exit 1



name: CI/CD Odoo ABCD

on:
  push:
    branches: ["main"]

jobs:

################################################################################
#                               1.   TESTS
################################################################################
  test:
    name: Test Odoo Modules
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install Python dependencies for linting
        run: |
          sudo apt update
          sudo apt install -y python3 python3-pip
          pip3 install pylint odoolint

      - name: Lint Python
        run: |
          pylint addons/* || true

      - name: Lint XML
        run: |
          odoolint addons/ || true

      - name: Clean old test containers
        run: |
          docker compose -f docker-compose.test.yml down -v || true

      - name: Run Odoo tests
        run: |
          docker compose -f docker-compose.test.yml up \
            --abort-on-container-exit \
            --exit-code-from odoo
        continue-on-error: false


################################################################################
#                               2.   DEPLOY
################################################################################
  deploy:
    name: Deploy to Server
    needs: test
    runs-on: self-hosted
    env:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      SMTP_HOST: ${{ secrets.SMTP_HOST }}
      SMTP_PORT: ${{ secrets.SMTP_PORT }}
      SMTP_USER: ${{ secrets.SMTP_USER }}
      SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
      SMTP_USE_SSL: ${{ secrets.SMTP_USE_SSL }}
      ADMIN_EMAILS: ${{ secrets.ADMIN_EMAILS }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0   # nécessaire pour comparer les commits

      - name: Sync project to server
        run: |
          rsync -avz --delete \
            ./ \
            $HOME/firstodoo/

      - name: Install Python dependencies (requirements.txt)
        run: |
          cd $HOME/firstodoo
          if [ -f requirements.txt ]; then
            sudo pip3 install -r requirements.txt
          fi

      - name: Stop old containers
        run: |
          cd $HOME/firstodoo
          docker-compose down || true

      - name: Rebuild and start containers (with retry)
        run: |
          cd $HOME/firstodoo
          for i in {1..5}; do
            docker-compose up -d --build && break
            echo "Retrying build ($i/5)..."
            sleep 3
          done

      - name: Detect changed Odoo modules
        id: changed
        run: |
          set -euo pipefail
          BASE_SHA="${{ github.event.before }}"
          HEAD_SHA="${{ github.sha }}"

          # Si github.event.before est null (nouvelle branche ou premier push)
          if [ "$BASE_SHA" = "0000000000000000000000000000000000000000" ] || [ -z "$BASE_SHA" ]; then
            BASE_SHA=$(git rev-list --max-parents=0 HEAD | tail -n 1)
          fi

          echo "Diff from $BASE_SHA to $HEAD_SHA"

          mods=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA" -- 'addons/*' 'custom_addons/*' \
            | awk -F/ '
                $1=="addons"{print $2}
                $1=="custom_addons"{print $2}
              ' \
            | sort -u \
            | paste -sd, -)

          if [ -z "$mods" ]; then
            echo "no module changed"
            echo "modules=NONE" >> $GITHUB_OUTPUT
            echo "modules_count=0" >> $GITHUB_OUTPUT
          else
            echo "modules=$mods" >> $GITHUB_OUTPUT
            echo "modules_count=$(echo "$mods" | tr ',' '\n' | wc -l)" >> $GITHUB_OUTPUT
          fi

      - name: Update only changed modules
        if: steps.changed.outputs.modules != 'NONE'
        run: |
          set -euo pipefail
          IFS=',' read -ra MODS <<< "${{ steps.changed.outputs.modules }}"
          for mod in "${MODS[@]}"; do
            echo "Updating module: $mod"
            docker exec odoo18 \
              odoo -d odoo18 \
                  -u "$mod" \
                  --db_host=db \
                  --db_port=5432 \
                  --db_user=odoo18 \
                  --db_password=odoo18 \
                  --stop-after-init
          done

      - name: Rollback on failure
        if: failure()
        run: |
          echo "DEPLOY FAILED — ROLLBACK IN PROGRESS"
          cd $HOME/firstodoo
          git reset --hard HEAD~1
          docker-compose down || true
          docker-compose up -d --build
          exit 1

      - name: Deep healthcheck (robust)
        run: |
          set -euo pipefail

          echo "1) Vérifier que le container odoo18 est en cours d'exécution..."
          if ! docker ps --format '{{.Names}}' | grep -q '^odoo18$'; then
            echo "ERROR: le container odoo18 n'est pas démarré."
            docker ps -a --format "table {{.Names}}\t{{.Status}}"
            docker logs odoo18 || true
            exit 1
          fi

          echo "2) Attente du port HTTP (8069) avec retries (120s max)..."
          max_wait=120
          waited=0
          interval=3
          until curl -sSf http://localhost:8069/ || {
            waited=$((waited+interval))
            if [ "$waited" -ge "$max_wait" ]; then
              echo "Échec: service HTTP non disponible après ${max_wait}s"
              break
            fi
            echo "Attente ${waited}s..."
            sleep $interval
            false
          }; do :; done

          # Si curl n'a jamais réussi, afficher logs et sortir en erreur
          if ! curl -sSf http://localhost:8069/ >/dev/null 2>&1; then
            echo "=== Logs Odoo (dernier 500 lines) ==="
            docker logs --tail 500 odoo18 || true
            echo "Vérifie : port exposé, erreur de démarrage, dépendances manquantes."
            exit 1
          fi

          echo "3) Vérifier l'absence d'erreurs critiques dans les logs (dernier 500 lines)..."
          if docker logs --tail 500 odoo18 2>&1 | grep -iE "traceback|error|critical" >/dev/null; then
            echo "WARN/ERROR trouvé dans les logs. Affichage des lignes pertinentes :"
            docker logs --tail 500 odoo18 2>&1 | grep -iE "traceback|error|critical" || true
            # si tu veux faire échouer le job sur ces erreurs, décommente la ligne suivante
            # exit 1
          else
            echo "Pas d'erreurs critiques détectées dans les derniers logs."
          fi

          echo "4) Check final : requête JSON d'index Odoo (pour vérifier réponse HTTP correcte)..."
          if ! curl -sSf http://localhost:8069/web/database/selector >/dev/null 2>&1; then
            echo "La route /web/database/selector n'a pas répondu comme attendu."
            docker logs --tail 500 odoo18 || true
            exit 1
          fi

          echo "Odoo deployment OK"

      - name: Notify admins (Slack webhook)
        if: always()
        env:
          STATUS: ${{ job.status }}
          MODULES: ${{ steps.changed.outputs.modules }}
          MODULES_COUNT: ${{ steps.changed.outputs.modules_count }}
        run: |
          if [ -z "${SLACK_WEBHOOK_URL:-}" ]; then
            echo "SLACK_WEBHOOK_URL non configurée, notification sautée."
            exit 0
          fi

          short_sha=$(echo "${GITHUB_SHA}" | cut -c1-8)
          payload=$(cat <<EOF
          {
            "text": ":information_source: Déploiement Odoo",
            "attachments": [
              {
                "color": "STATUS_COLOR",
                "title": "Statut: STATUS_TEXT",
                "fields": [
                  { "title": "Répo", "value": "${GITHUB_REPOSITORY}", "short": true },
                  { "title": "Commit", "value": "${GITHUB_REF_NAME}@${short_sha}", "short": true },
                  { "title": "Modules modifiés", "value": "MODULES_VALUE", "short": false },
                  { "title": "Run", "value": "${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}", "short": false }
                ]
              }
            ]
          }
          EOF
          )

          if [ "$STATUS" = "success" ]; then
            color="#36a64f"
            status_text="Succès"
          else
            color="#d00000"
            status_text="Échec"
          fi

          modules_value="$MODULES"
          if [ -z "$modules_value" ] || [ "$modules_value" = "NONE" ]; then
            modules_value="Aucun module détecté"
          fi

          payload=${payload//STATUS_COLOR/$color}
          payload=${payload//STATUS_TEXT/$status_text}
          payload=${payload//MODULES_VALUE/$modules_value}

          curl -X POST -H 'Content-type: application/json' \
            --data "$payload" \
            "$SLACK_WEBHOOK_URL"

      - name: Notify admins (Email SMTP)
        if: always()
        env:
          STATUS: ${{ job.status }}
          MODULES: ${{ steps.changed.outputs.modules }}
          MODULES_COUNT: ${{ steps.changed.outputs.modules_count }}
        run: |
          if [ -z "${SMTP_HOST:-}" ] || [ -z "${SMTP_USER:-}" ] || [ -z "${SMTP_PASSWORD:-}" ] || [ -z "${ADMIN_EMAILS:-}" ]; then
            echo "SMTP_HOST, SMTP_USER, SMTP_PASSWORD ou ADMIN_EMAILS non configurés, notification email sautée."
            exit 0
          fi

          # Valeurs par défaut pour SMTP_PORT et SMTP_USE_SSL
          SMTP_PORT="${SMTP_PORT:-587}"
          SMTP_USE_SSL="${SMTP_USE_SSL:-false}"

          short_sha=$(echo "${GITHUB_SHA}" | cut -c1-8)
          
          if [ "$STATUS" = "success" ]; then
            status_emoji="✅"
            status_text="Succès"
            status_color="#36a64f"
            status_title="Déploiement réussi"
          else
            status_emoji="❌"
            status_text="Échec"
            status_color="#d00000"
            status_title="Déploiement échoué"
          fi

          modules_value="$MODULES"
          if [ -z "$modules_value" ] || [ "$modules_value" = "NONE" ]; then
            modules_value="Aucun module détecté"
            modules_count_text=""
          else
            modules_count_text=" ($MODULES_COUNT module(s))"
          fi

          # Corps HTML (fichier) pour améliorer la délivrabilité (OVH filtre parfois le pur HTML)
          cat <<EOF > /tmp/email_body.html
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="UTF-8">
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
              <h2 style="color: ${status_color}; margin-top: 0;">
                ${status_emoji} ${status_title}
              </h2>
              
              <div style="background-color: #f5f5f5; padding: 15px; border-radius: 5px; margin: 20px 0;">
                <h3 style="margin-top: 0; color: #333;">Informations du déploiement</h3>
                <p><strong>Répository:</strong> ${GITHUB_REPOSITORY}</p>
                <p><strong>Branche:</strong> ${GITHUB_REF_NAME}</p>
                <p><strong>Commit:</strong> <code>${short_sha}</code></p>
                <p><strong>Auteur:</strong> ${GITHUB_ACTOR}</p>
                <p><strong>Statut:</strong> <span style="color: ${status_color}; font-weight: bold;">${status_text}</span></p>
              </div>

              <div style="background-color: #e8f4f8; padding: 15px; border-radius: 5px; margin: 20px 0;">
                <h3 style="margin-top: 0; color: #333;">Modules modifiés</h3>
                <p>${modules_value}${modules_count_text}</p>
              </div>

              <div style="margin: 20px 0;">
                <p><strong>Lien vers le workflow:</strong></p>
                <p><a href="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}" style="color: #0366d6; text-decoration: none;">
                  Voir les détails du déploiement
                </a></p>
              </div>

              <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;">
              
              <p style="color: #666; font-size: 12px;">
                Ce message a été envoyé automatiquement par GitHub Actions.
              </p>
            </div>
          </body>
          </html>
          EOF

          # Version texte (plain) pour les filtres anti-spam
          cat <<EOF > /tmp/email_body.txt
          [Odoo Deployment] ${status_text} - ${GITHUB_REPOSITORY}

          Statut : ${status_text}
          Repository : ${GITHUB_REPOSITORY}
          Branche : ${GITHUB_REF_NAME}
          Commit : ${short_sha}
          Auteur : ${GITHUB_ACTOR}
          Modules : ${modules_value}${modules_count_text}

          Workflow : ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}
          EOF

          email_subject="[Odoo Deployment] ${status_emoji} ${status_text} - ${GITHUB_REPOSITORY}"

          # Exporter les variables pour le script Python
          export EMAIL_SUBJECT="$email_subject"
          export SMTP_PORT
          export SMTP_USE_SSL

          # Envoyer l'email via Python avec smtplib
          python3 <<PYTHON_SCRIPT
          import smtplib
          from email.mime.text import MIMEText
          from email.mime.multipart import MIMEMultipart
          import os

          smtp_host = os.environ['SMTP_HOST']
          smtp_port = int(os.environ.get('SMTP_PORT', '587'))
          smtp_user = os.environ['SMTP_USER']
          smtp_password = os.environ['SMTP_PASSWORD']
          smtp_use_ssl = os.environ.get('SMTP_USE_SSL', 'false').lower() == 'true'
          admin_emails = [email.strip() for email in os.environ['ADMIN_EMAILS'].split(',')]
          subject = os.environ['EMAIL_SUBJECT']
          
          with open('/tmp/email_body.html', 'r', encoding='utf-8') as f:
              body_html = f.read()
          with open('/tmp/email_body.txt', 'r', encoding='utf-8') as f:
              body_text = f.read()

          msg = MIMEMultipart('alternative')
          msg['Subject'] = subject
          msg['From'] = f"GitHub Actions <{smtp_user}>"
          msg['To'] = ', '.join(admin_emails)
          msg['Reply-To'] = smtp_user  # certains serveurs requièrent un Reply-To aligné

          # Ajouter une version texte + HTML pour limiter le classement en spam
          part_text = MIMEText(body_text, 'plain', 'utf-8')
          part_html = MIMEText(body_html, 'html', 'utf-8')
          msg.attach(part_text)
          msg.attach(part_html)

          try:
              # Connexion SMTP selon le type (SSL ou TLS)
              if smtp_use_ssl:
                  # Connexion SSL directe (port 465 généralement)
                  server = smtplib.SMTP_SSL(smtp_host, smtp_port)
                  server.ehlo()
              else:
                  # Connexion STARTTLS (port 587 généralement)
                  server = smtplib.SMTP(smtp_host, smtp_port)
                  server.ehlo()
                  server.starttls()
                  server.ehlo()
              
              # Activer les logs SMTP pour diagnostiquer (visible dans les logs du job)
              server.set_debuglevel(1)

              # Authentification
              server.login(smtp_user, smtp_password)
              
              # Envoi de l'email
              send_failures = server.sendmail(smtp_user, admin_emails, msg.as_string())
              server.close()
              
              print(f"SMTP: {smtp_host}:{smtp_port} (SSL: {smtp_use_ssl})")
              if send_failures:
                  print(f"Échec sur certains destinataires: {send_failures}")
                  exit(1)
              else:
                  print(f"Email envoyé avec succès à: {', '.join(admin_emails)}")
          except Exception as e:
              print(f"Erreur lors de l'envoi de l'email: {e}")
              import traceback
              traceback.print_exc()
              exit(1)
          PYTHON_SCRIPT
